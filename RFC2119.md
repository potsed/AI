# RFC 2119 Requirements

This document contains the complete RFC 2119 specification and additional interpretations that apply to all domains within the HATS framework.

## RFC 2119 Specification

### Status of this Memo

This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.

### Abstract

In many standards track documents several words are used to signify the requirements in the specification. These words are often capitalized. This document defines these words as they should be interpreted in IETF documents. Authors who follow these guidelines should incorporate this phrase near the beginning of their document:

> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

Note that the force of these words is modified by the requirement level of the document in which they are used.

### 1. MUST

This word, or the terms "REQUIRED" or "SHALL", mean that the definition is an absolute requirement of the specification.

### 2. MUST NOT

This phrase, or the phrase "SHALL NOT", mean that the definition is an absolute prohibition of the specification.

### 3. SHOULD

This word, or the adjective "RECOMMENDED", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.

### 4. SHOULD NOT

This phrase, or the phrase "NOT RECOMMENDED" mean that there may exist valid reasons in particular circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood and the case carefully weighed before implementing any behavior described with this label.

### 5. MAY

This word, or the adjective "OPTIONAL", mean that an item is truly optional. One vendor may choose to include the item because a particular marketplace requires it or because the vendor feels that it enhances the product while another vendor may omit the same item. An implementation which does not include a particular option MUST be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option MUST be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides.)

### 6. Guidance in the use of these Imperatives

Imperatives of the type defined in this memo must be used with care and sparingly. In particular, they MUST only be used where it is actually required for interoperation or to limit behavior which has potential for causing harm (e.g., limiting retransmisssions) For example, they must not be used to try to impose a particular method on implementors where the method is not required for interoperability.

### 7. Security Considerations

These terms are frequently used to specify behavior with security implications. The effects on security of not implementing a MUST or SHOULD, or doing something the specification says MUST NOT or SHOULD NOT be done may be very subtle. Document authors should take the time to elaborate the security implications of not following recommendations or requirements as most implementors will not have had the benefit of the experience and discussion that produced the specification.

### 8. Acknowledgments

The definitions of these terms are an amalgam of definitions taken from a number of RFCs. In addition, suggestions have been incorporated from a number of people including Robert Ullmann, Thomas Narten, Neal McBurnett, and Robert Elz.

### 9. Author's Address

Scott Bradner
Harvard University
1350 Mass. Ave.
Cambridge, MA 02138
phone - +1 617 495 3864
email - sob@harvard.edu

## Additional Interpretations

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

Additional interpretations follow the [OASIS Keyword Guidelines](https://www.oasis-open.org/policies-guidelines/keyword-guidelines/) which provide important standards for using RFC 2119 keywords in technical specifications.

## Generic Requirements

**MUST** follow established branching strategy (e.g., GitFlow, GitHub Flow, Trunk-Based Development)
**MUST** create feature branches from the main branch
**MUST** delete feature branches after merging
**MUST** use descriptive branch names (e.g., feature/user-authentication)
**MUST** regularly sync feature branches with the main branch
**SHOULD** use short-lived feature branches (less than 3 days)
**MUST NOT** commit directly to the main branch

**MUST** follow conventional commit message format
**MUST** use present tense in commit messages
**MUST** capitalize the first letter of commit messages
**MUST** keep commit messages under 72 characters
**MUST** use blank line between subject and body
**MUST** reference issue numbers in commit messages
**SHOULD** explain the "why" not just the "what" in commit messages

**MUST** create pull requests for all changes
**MUST** have at least one approval before merging
**MUST** address all review comments before merging
**MUST** run all tests successfully before requesting review
**MUST** keep pull requests small and focused
**SHOULD** assign appropriate reviewers based on expertise
**MUST NOT** merge pull requests with failing checks

**MUST** verify code follows project coding standards
**MUST** check for security vulnerabilities
**MUST** validate error handling and edge cases
**MUST** ensure code is testable and tested
**MUST** verify documentation is updated
**SHOULD** check for performance implications
**MUST NOT** approve code that doesn't meet quality standards

**MUST** evaluate code readability and maintainability
**MUST** check for code duplication
**MUST** verify appropriate use of design patterns
**MUST** assess complexity and cyclomatic complexity
**MUST** ensure proper separation of concerns
**SHOULD** look for opportunities for improvement
**MUST NOT** ignore code smells or anti-patterns

**MUST** check for common security vulnerabilities
**MUST** verify input validation and sanitization
**MUST** ensure proper authentication and authorization
**MUST** check for sensitive data exposure
**MUST** validate dependency security
**SHOULD** use automated security scanning tools
**MUST** address security findings promptly

**MUST** verify adequate test coverage
**MUST** check test quality and clarity
**MUST** ensure tests are deterministic
**MUST** validate edge case coverage
**MUST** verify test data appropriateness
**SHOULD** suggest additional test scenarios
**MUST** confirm tests pass consistently

**MUST** verify code is self-documenting
**MUST** check for appropriate comments
**MUST** ensure documentation is updated
**MUST** validate API documentation accuracy
**MUST** confirm README updates
**SHOULD** suggest documentation improvements
**MUST** verify inline documentation clarity

**MUST** identify potential performance bottlenecks
**MUST** check for resource leaks
**MUST** validate algorithm efficiency
**MUST** ensure appropriate caching usage
**MUST** verify database query efficiency
**SHOULD** suggest performance optimizations
**MUST** consider scalability implications

**MUST** provide constructive feedback
**MUST** explain reasoning for suggestions
**MUST** respect authors and their work
**MUST** focus on code, not individuals
**MUST** be responsive to questions and discussions
**SHOULD** acknowledge good practices and improvements
**MUST NOT** use review process for personal preferences

**MUST** respond to review requests within 24 hours
**MUST** provide initial feedback within 48 hours
**MUST** complete reviews within 72 hours
**MUST** prioritize urgent or blocking reviews
**MUST** communicate delays proactively
**SHOULD** conduct reviews in timely manner
**MUST** respect team review capacity

**MUST** use fast-forward merges when possible
**MUST** use squash merges for feature branches
**MUST** preserve commit history for significant changes
**MUST** resolve merge conflicts before merging
**MUST** verify changes after merge
**SHOULD** use merge commits for significant releases
**MUST NOT** rewrite public commit history

**MUST** maintain a clean project root directory
**MUST** use appropriate .gitignore files
**MUST** document repository structure
**MUST** keep sensitive information out of the repository
**MUST** use submodules for external dependencies when appropriate
**SHOULD** use meaningful directory structures
**MUST NOT** commit generated files

**MUST** use semantic versioning for releases
**MUST** create annotated tags for releases
**MUST** document release notes for each tag
**MUST** follow established release process
**MUST** verify releases before publishing
**SHOULD** use pre-release tags for beta versions
**MUST NOT** modify existing tags

**MUST** maintain a clean, linear history when possible
**MUST** avoid unnecessary merge commits
**MUST** write descriptive commit messages
**MUST** preserve important historical context
**MUST** use revert commits for undoing changes
**SHOULD** use interactive rebasing for cleaning up history
**MUST NOT** use force push on shared branches

**MUST** communicate with team before large changes
**MUST** respect team conventions and standards
**MUST** provide context in pull requests
**MUST** respond to review comments promptly
**MUST** test changes in isolation before merging
**SHOULD** pair program for complex changes
**MUST NOT** ignore failing tests or checks

**MUST** adhere to language-specific style guides and best practices
**MUST** fully utilize type systems in typed languages
**MUST** run linting tools on all code and address failures before merge
**MUST** use language-specific formatting tools
**MUST** be reviewed for idiomatic usage of the language and frameworks
**MUST NOT** reinvent the wheel
**MUST NOT** merge undeclared deviations

## Process RFC 2119 Requirements

For Human-AI collaboration process requirements:

**MUST** defer to human expertise when uncertain or when human knowledge is explicitly required
**MUST** provide confidence levels with recommendations
**MUST** engage in explicit agreement processes before implementation
**MUST** document its limitations and knowledge gaps
**MUST** state confidence levels with all recommendations
**MUST** explicitly identify knowledge gaps and limitations
**MUST** engage in explicit agreement before implementation
**SHOULD** provide multiple options when appropriate with trade-offs
**MUST** capture and learn from human corrections
**MUST** include Human-AI collaboration assessment in regular retrospectives
**SHOULD** conduct AI capability assessments quarterly
**SHOULD** hold regular knowledge transfer sessions
**SHOULD** have human-led complex, creative, and strategic work with AI assistance
**MAY** have AI-led repetitive, well-defined, and routine work with human oversight
**MUST** have human review for critical business logic regardless of AI confidence
**MUST** defer to human expertise in domain-specific areas
**MUST** receive human review for AI-generated code
**MAY** receive AI suggestions for improvement for human-generated code
**SHOULD** establish hybrid peer review processes
**MUST** track AI contribution quality metrics

**MUST** consult the latest official docs for any technology before writing or changing code that uses it
**MUST** capture version and links in the PR description
**MUST** Use official documentation (always up front) for libraries and APIs
**MUST** ask clarifying questions and propose options until explicit agreement on the plan when neither SME nor AI is assumed correct
**MUST** Use SME-led development: ask clarifying questions, don't assume
**MUST** Understand the full code context before generating code
**MUST** Keep things DRY (Don't Repeat Yourself)
**MUST** Apply software design patterns to keep code maintainable, extendable, and stable
**MUST** Apply sound architectural principles
**MUST** Use MCP tools when available

**MUST** READ BOTH documents IN THEIR ENTIRETY BEFORE ANY CONTRIBUTION for ALL AI CONTRIBUTORS
**MUST** MEMORIZE AND ADHERE TO ALL PROCESSES AND GUARDRAILS WITHOUT EXCEPTION for ALL AI CONTRIBUTORS
**MUST** VERIFY EVERY CONTRIBUTION AGAINST ALL MANDATORY REQUIREMENTS for ALL AI CONTRIBUTORS
**MUST** ENSURE ALL CODE, DOCUMENTATION, AND COMMUNICATIONS FOLLOW THE EXACT SPECIFIED FORMATS for ALL AI CONTRIBUTORS
**MUST** DOCUMENT KEY DECISIONS, RISKS, AND PATTERNS AS PART OF EACH CONTRIBUTION for ALL AI CONTRIBUTORS

**MUST** PRIORITIZE QUALITY OVER QUANTITY in all contributions for ALL AI CONTRIBUTORS
**MUST** MINIMIZE TOKEN USAGE without detriment to service quality or task completion for ALL AI CONTRIBUTORS
**MUST** WORK BOTH SYNCHRONOUSLY AND ASYNCHRONOUSLY as needed for optimal resource utilization for ALL AI CONTRIBUTORS
**MUST NOT** COMPROMISE QUALITY FOR TOKEN SAVINGS for ALL AI CONTRIBUTORS
**MUST** USE ASYNC PROCESSING to maximize throughput and minimize blocking operations for ALL AI CONTRIBUTORS
**SHOULD** IMPLEMENT EFFICIENT WORKFLOW DESIGNS for ALL AI CONTRIBUTORS
**MUST** MONITOR TOKEN USAGE and optimize where possible for ALL AI CONTRIBUTORS
**MUST NOT** ACCEPT SUBOPTIMAL RESOURCE UTILIZATION for ALL AI CONTRIBUTORS
**MUST** ENSURE RESOURCE OPTIMIZATION DOES NOT COMPROMISE QUALITY for ALL AI CONTRIBUTORS
**SHOULD** USE SMART WORKFLOW DESIGN AND ASYNC PROCESSING for ALL AI CONTRIBUTORS

**MUST** have a written waiver in the PR description including scope, rationale, compensating controls, expiry date (â‰¤ 30 days), and responsible owner for any deviation from these guardrails
**MUST** track waivers and either resolve or re-approve before expiry
**MUST NOT** merge undeclared deviations

For detailed requirements specific to each functional domain, please see the RFC2119.md files in each directory:

- [`marketing/RFC2119_MARKETING.md`](marketing/RFC2119_MARKETING.md) - Marketing requirements
- [`design/RFC2119_DESIGN.md`](design/RFC2119_DESIGN.md) - Design requirements (placeholder)
- [`hr/RFC2119_HR.md`](hr/RFC2119_HR.md) - Human resources requirements (placeholder)
- [`finance/RFC2119_FINANCE.md`](finance/RFC2119_FINANCE.md) - Finance requirements (placeholder)