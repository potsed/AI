# RFC 2119 Requirements Organized Logically

This document contains all unique RFC 2119 requirements from PURPOSE.md, GUARDRAILS.md, and AI.md files, organized by logical categories.

## Code Structure and ATOMIC Principles

**SHOULD** target files at ≤ 100 lines
**MUST NOT** exceed 200 lines per file

**SHOULD** target functions at ≤ 25 lines
**MUST NOT** exceed 40 lines per function

**SHOULD** maintain cyclomatic complexity at ≤ 10
**MUST NOT** exceed cyclomatic complexity of 15

**MUST** ensure each module has a single responsibility

**MUST** refactor files that exceed hard caps before merge

**MUST** live in separate modules for route wiring, validation, business logic, and IO

**MUST** maintain or improve atomicity, clarity, and safety with every change

**MUST** remove dead code

## Libraries and Infrastructure

**MUST** use maintained, widely-adopted libraries or platform features for infrastructure/commodity capabilities

**MUST NOT** write custom implementations of commodity concerns

**MUST** use libraries first for infrastructure

**MUST NOT** hand-roll HTTP servers/routers, authentication/OAuth/OIDC, cryptography (HMAC, JWT, AES, hashing), database clients/query engines, queueing/scheduling, session management, logging frameworks, configuration loaders, retry backoff engines - use established, maintained solutions

**MUST** Write custom code only for business logic

**MUST** limit bespoke code to domain-specific logic, glue, and adapters

## Testing and Quality Assurance

**MUST** start new or changed business logic with a failing test

**MUST** Use TDD for business logic; don't test third-party libraries

**MUST NOT** unit-test third-party libraries internally; **MUST** mock/stub their edges

**MUST** be green without exception for all tests

**MUST** meet ≥ 80% line and ≥ 70% branch coverage for business logic (or project-defined stricter gates)

**MUST** fix or quarantine flakiness within 48h for deterministic tests and stable CI

**MUST** fix or quarantine any flaky test within 48 hours

**SHOULD** complete unit tests in ≤ 3 minutes in CI

**MUST** Investigate failing tests (test issue vs. code issue)

**MUST** Follow QA best practices (unit, integration, E2E, contract tests)

## Input Validation and Error Handling

**MUST** validate all inputs from any source against explicit schemas or rules before use

**MUST** fail fast with clear, safe errors for invalid input

**MUST** apply sanitization/normalization where appropriate

**MUST NOT** swallow or ignore errors/exceptions

**MUST** classify errors, log without sensitive data, surface appropriately, and handle to fail safe (closed)

## Security and Secrets Management

**MUST NOT** exist in code, history, sample env files, or documentation for secrets

**MUST** use centralized secret storage with rotation and least privilege

**MUST** rotate keys at least quarterly or on incident

**MUST** document rotation plans

**MUST** be secure for all code

**MUST** be secure and follow best practices for databases

**MUST** Apply security best practices (OWASP-grade)

## Documentation and Knowledge Management

**MUST** update documentation in the same PR as behavior/config changes

**MUST** Maintain human-readable documentation aligned with the project

**MUST** ensure humans can run locally with clear instructions

**MUST** document any new endpoint, env var, flag, migration, or permission in the same PR

**MUST** document key decisions in Architecture Decision Records (ADRs)

**MUST** capture successful patterns and anti-patterns for future reference

**MUST** identify and document risks and mitigations

**MUST** document deploy, rollback, incident response, and on-call procedures in `/docs/runbooks/`

**MUST** have clear run instructions for the application for the SME

**MUST** be able to run tests locally for the SME

## Dependencies and Supply Chain

**MUST** use latest stable versions for dependencies unless a documented waiver exists

**MUST** address breaking changes

**MUST** commit lockfiles for reproducibility

**MUST** generate a Software Bill of Materials for each release

**MUST** fail CI on High/Critical issues unless a time-boxed waiver is approved

**MUST** be active, maintained, documented, and widely trusted for dependencies

**MUST** satisfy and document licensing, privacy, accessibility, and industry-specific regulations

## Observability and Monitoring

**MUST** present correlation/request identifiers

**MUST** set appropriate logging levels for environment

**MUST** expose basic availability, latency, and error metrics for services

**MUST** have health/readiness endpoints where applicable

**MUST** log critical actions with who/what/when/where in an immutable or tamper-evident way

## Data Management

**MUST** classify data (e.g., Public/Private/Sensitive) and handle accordingly

**MUST** define and enforce retention periods per data class

**MUST** back up production data at least daily

**MUST** test restores quarterly

**MUST** apply least privilege to databases and storage

**MUST** make sensitive operations auditable

## Performance and Reliability

**MUST** have p95 latency and error budgets defined for each critical endpoint/job

**MUST** exist for rate limiting/throttling for public and tenant-scoped entry points

**MUST** be idempotent for all externally visible operations subject to retries

**MUST** be idempotent for external-facing side effects (enforced via keys/sequencing)

**MUST** meet performance benchmarks for core user journeys

**SHOULD** have performance benchmarks for critical paths

**SHOULD** conduct safe, small-scale chaos experiments for critical services

## Accessibility and Internationalization

**MUST** meet WCAG AA minimum for UIs

**MUST** satisfy and evidence controls if in scope (e.g., PCI-DSS, SOC 2)

**MUST** document WCAG compliance for UI

**SHOULD** externalize strings where localization is in scope

## Feature Management

**MUST** flag-gate new features

**MUST** default flags off

**MUST** default kill switches on and document them

**MUST** Use feature flags to isolate new or risky features

## Development Process and Collaboration

**MUST** consult the latest official docs for any technology before writing or changing code that uses it

**MUST** capture version and links in the PR description

**MUST** Use official documentation (always up front) for libraries and APIs

**MUST** ask clarifying questions and propose options until explicit agreement on the plan when neither SME nor AI is assumed correct

**MUST** Use SME-led development: ask clarifying questions, don't assume

**MUST** Understand the full code context before generating code

**MUST** Keep things DRY (Don't Repeat Yourself)

**MUST** Apply software design patterns to keep code maintainable, extendable, and stable

**MUST** Apply sound architectural principles

**MUST** Use MCP tools when available

## Human-AI Collaboration Framework

**MUST** defer to human expertise when uncertain or when human knowledge is explicitly required

**MUST** provide confidence levels with recommendations

**MUST** engage in explicit agreement processes before implementation

**MUST** document its limitations and knowledge gaps

**MUST** state confidence levels with all recommendations

**MUST** explicitly identify knowledge gaps and limitations

**MUST** engage in explicit agreement before implementation

**SHOULD** provide multiple options when appropriate with trade-offs

**MUST** capture and learn from human corrections

**MUST** include Human-AI collaboration assessment in regular retrospectives

**SHOULD** conduct AI capability assessments quarterly

**SHOULD** hold regular knowledge transfer sessions

**SHOULD** have human-led complex, creative, and strategic work with AI assistance

**MAY** have AI-led repetitive, well-defined, and routine work with human oversight

**MUST** have human review for critical business logic regardless of AI confidence

**MUST** defer to human expertise in domain-specific areas

**MUST** receive human review for AI-generated code

**MAY** receive AI suggestions for improvement for human-generated code

**SHOULD** establish hybrid peer review processes

**MUST** track AI contribution quality metrics

## AI-Specific Requirements

**MUST** READ BOTH documents IN THEIR ENTIRETY BEFORE ANY CONTRIBUTION for ALL AI CONTRIBUTORS

**MUST** MEMORIZE AND ADHERE TO ALL PROCESSES AND GUARDRAILS WITHOUT EXCEPTION for ALL AI CONTRIBUTORS

**MUST** VERIFY EVERY CONTRIBUTION AGAINST ALL MANDATORY REQUIREMENTS for ALL AI CONTRIBUTORS

**MUST** ENSURE ALL CODE, DOCUMENTATION, AND COMMUNICATIONS FOLLOW THE EXACT SPECIFIED FORMATS for ALL AI CONTRIBUTORS

**MUST** DOCUMENT KEY DECISIONS, RISKS, AND PATTERNS AS PART OF EACH CONTRIBUTION for ALL AI CONTRIBUTORS

## Builds and Deployment

**MUST** ensure builds are reproducible (pinned toolchains and lockfiles)

**MUST** not break things, if you break it you fix it — all code must pass tests

**MUST** be production-ready and deployable for all code

## Governance and Compliance

**MUST** have a written waiver in the PR description including scope, rationale, compensating controls, expiry date (≤ 30 days), and responsible owner for any deviation from these guardrails

**MUST** track waivers and either resolve or re-approve before expiry

**MUST NOT** merge undeclared deviations

## CI/CD Enforcement

**MUST** block merges if tests are not green or coverage is below gates

**MUST** block merges if atomicity hard caps are exceeded

**MUST** block merges if dependency vulnerability or license checks fail without waiver

**MUST** block merges if linting/static analysis/type checks fail

**MUST** block merges if required docs are missing or out of date

**MUST** block merges if compliance checklist is incomplete (when in scope)

**MUST** block merges if SME local run/test instructions are missing or not updated

**MUST** block merges if required approvals/reviews are absent

## Code Quality Standards

**MUST** adhere to language-specific style guides and best practices

**MUST** fully utilize type systems in typed languages

**MUST** run linting tools on all code and address failures before merge

**MUST** use language-specific formatting tools

**MUST** be reviewed for idiomatic usage of the language and frameworks

## Prohibited Practices

**MUST NOT** reinvent the wheel

**MUST NOT** merge undeclared deviations
